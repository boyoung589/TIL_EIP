# 13 포인터

---

```c
int a = 10;
int* b = &a;
```

1. r개념: 변수의 주솟값을 저장하는 공간
2. 사용
    1. 자료형 뒤에  *를 붙이면 주소를 저장하는 포인터 변수라는 의미
    2. 일반 변수명에 &를 붙이면 해당 변수명의 주솟값
    3. *와 &는 반대개념이므로 *(&)로 같이 사용시 상쇄됨
    
    ```c
    #include <stdio.h>
    int main(){
    	int a = 10;
    	int* b = &a;
    	printf("%d %d %d", a, *b, *(&a));
    	return 0;
    }
    // 출력 : 10 10 10
    ```
    
    1. 정수형 변수 a 선언 후 10으로 초기화
    2. b라는 포인터 변수에 a의 주솟값을 저장
    3. a는 10이 저장되어 있으므로 10 출력
    4. *b는 b라는 포인터 변수가 저장하고 있는 주소에 있는 값을 출력하라는 의미이므로, a의 주솟값에 저장된 값인 a를 출력
        1. b가 가리키는(*) 값은 a이므로 *b와 a는 값이 같음
    5. *(&)를 사용시 상쇄됨으로 a의 값 출력
3. 배열과 포인터
    - 배열의 i번지 주소와 i번지 값
        
        ```c
        int s[3];
        /**
              s[0] s[1] s[2]
        주소값   s   s+1  s+2
        **/
        ```
        
        | 배열의 i번째 주소 | 배열+i == &배열[i] |
        | --- | --- |
        | 배열의 i번째 값 | *(배열+i) == 배열[i] |
    1. 1차원 배열과 1차원 포인터
        1. 1차원 배열에서 배열명만 단독으로 사용할 경우 1차원 포인터와 동일
        2. 1차원 배열일 때: `배열명[ 인덱스 ]` / `*( 배열명 + 인덱스 )`
        3. 1차원 포인터일 때: `포인터[ 인덱스 ]` / `*( 포인터 + 인덱스 )`
            - 예시
                1. 메모리 구조
                `int a[3] = {1, 2};`
                `int *p = a;`
                    
                    
                    |  | 주기억장치 |  |
                    | --- | --- | --- |
                    | &a[0] == a | 1 | a[0] == *a |
                    | &a[1] == (a+1) | 2 | a[1] == *(a+1) |
                    | &a[2] == (a+2) | 3 | a[2] == *(a+2) |
                    |  |  |  |
                    | p | a 의 주소 |  |
                
                ```c
                #include`<stdio.h>
                int main(){ 
                	int a[3] = {1, 2};
                	int *p = a;
                	printf("%d %d %d\n", a[0], a[1], a[2]);
                	printf("%d %d %d\n", *a, *(a+1), *(a+2));
                	printf("%d %d %d\n", *p, *(p+1), *(p+2));
                	printf("%d %d %d\n", p[0], p[1], p[2]);
                	return 0;
                }
                /** 출력
                1 2 0
                1 2 0
                1 2 0
                1 2 0
                **/
                
                ```
                
                1. 3자리의 정수 배열 a 선언 후 각각 인덱스에 1,2,0 값으로 초기화
                    
                    
                    | 인덱스 | 0 | 1 | 2 |
                    | --- | --- | --- | --- |
                    | a  | 1 | 2 | 0 |
                2. 정수형 포인터 p에 a의 주솟값 대입
                    1. p값과 a의 값이 같으므로 동일한 결과 도출 가능
                3. a의 0번째 인덱스값, a의 1번째 인덱스값, a의 2번째 인덱스값 출력
                4. a = &a[0] 이므로 *a == *(&a)로 *a == a
                    1. a[0], a[1], a[2] 값 출력
                5. p라는 포인터 변수에 저장된 주솟값이 a의 주솟값과 같으므로 
                    1. *p, *p+1, *p+2 는 *a, *a+1, *a+2와 동일하게 출력
                6. p라는 포인터 변수에 저장된 주솟값이 a의 주솟값과 같으므로
                    1. p[0], p[1], p[2]는 a[0], a[1], a[2]와 동일하게 출력
    2. 2차원 배열과 1차원 포인터
        1. 2차원 배열에서 배열명만 단독으로 사용할 경우 2차원 포인터와 동일
        2. 2차원 배열일 때: 베열명[ 인덱스 ] / *(배열명+인덱스) ⇒ 1차원 포인터와 동일
        3. `*`, `[]` 를 이용해야 1차원 포인터의 값을 가리킬 수 있ㅇ
        - 예시
            1. 메모리 구조
            `a[3][2] = {{1,2},{3,4},{5,6}};`
            `int *p = a[1];`
            
            |  | 0 | 1 |
            | --- | --- | --- |
            | a[0] | 1 | 2 |
            | a[1] | 3 | 4 |
            | a[2] | 5 | 6 |
            
            |  | 주기억장치 |  |
            | --- | --- | --- |
            | &a[0][0] ==a[0] | 1 | a[0][0] |
            | &a[0][1] | 2 | a[0][1] |
            | &a[1][0] ==a[1] | 3 | a[1][0] |
            | &a[1][1] | 4 | a[1][1] |
            | &a[2][0] ==a[2] | 5 | a[2][0] |
            | &a[2][1] | 6 | a[2][1] |
            |  |  |  |
            | p | a[1][0] 주소 |  |
            
            ```c
            #include <stdio.h>
            int main(){
            	int a[3][2] = {{1,2}, {3,4}, {5,6}};
            	int *p = a[1];
            	printf("%d %d %d\n", *a[0], *a[1], *a[2]);
            	printf("%d %d %d\n", **a, **(a+1), **(a+2));
            	printf("%d %d\n", *p, *(p+1));
            	printf("%d %d\n", p[0], p[1]);
            }
            /** 출력
            1 3 5
            1 3 5
            3 4
            3 4
            **/
            ```
            
            1. 2차원 정수 배열 a를 선언하고 {{1,2}, {3,4}, {5,6}};로 초기화
            2. a[1]은 &a[1][0] 과 같음
                1. `a[1] == &a[1][0] ⇒ 배열+i == &배열[i] 에서 배열 자리에 a[1]을 i 자리에 0을 넣음`
                2. a[1][0] 주소를 p라는 포인터 변수에 저장
                3. int *를 빼면 p = a[1] 이므로 p대신에 a[1]을 넣어도 결과가 동일
            3. `printf("%d %d %d\n", *a[0], *a[1], *a[2]);`
                1. a[0]은 a[0][0]과 동일 `배열+인덱스 = &배열[인덱스]`
                *a[0] == *(&a[0][0]) 
                *(&)는 상쇄
                *a[0] = a[0][0] == 1
                2. a[1] == a[1][0]
                *a[1] == *(&a[1][0]) == a[1][0] == 3
                3. a[2] == a[2][0]
                *a[2] == *(&a[2][0]) == a[2][0] == 5
            4. `printf("%d %d %d\n", **a, **(a+1), **(a+2));`
                1. a == &a[0] = a[0][0]
                **a == **(&a[0])
                *(&)는 상쇄
                **a == *a[0] == a[0][0] == 1
                2. a+1 = &(a[1])
                **(a+1) == **(&a[1])
                *(&)는 상쇄
                **(a+1) == *a[1] == a[1][0] == 3
                3. a+2 = &a(a[2])
                **(a+2) = **(&a[2])
                *(&)는 상쇄
                **(a+2) == **a[2] == a[2][0] == 5
            5. `printf("%d %d\n", *p, *(p+1));`
                1. p == &a[1]
                *p == *(&a[1]) == a[1] ==3
                2. *(p+1) == *(a[1]+1) == a[1][1]
            6. `printf("%d %d\n", p[0], p[1]);`
                1. p == a[1]
                p[0] == a[1][0] == 3
                2. p == a[1]
                p[1] == a[1][1] ==4
    3. 2차원 배열과 포인터 배열
        - 예시
            1. 메모리 구조
            `int a[3][2] = {{1,2}, {3,4}, {5,6}};` 
            `int *p[3] = {a[2], a[0], a[1]};`
            
            |  | 주기억장치 |  |
            | --- | --- | --- |
            | p[1] | 1 | a[0][0] |
            |  | 2 | a[0][1] |
            | p[2] | 3 | a[1][0] |
            |  | 4 | a[1][1] |
            | p[0] | 5 | a[2][0] |
            |  | 6 | a[2][1] |
            |  |  |  |
            | p[0] | a[2] |  |
            | p[1] | a[0] |  |
            | p[2] | a[1] |  |
            
            ```c
            #include <stdio.h>
            int main(){
            	int a[3][2] = {{1,2}, {3,4}, {5,6}};
            	int *p[3] = {a[2], a[0], a[1]};
            	printf("%d %d %d\n", a[0][0], a[1][0], a[2][0]);
            	printf("%d %d %d\n", *a[0], *a[1], *a[2]);
            	printf("%d %d %d\n", p[1][0], p[2][0], p[0][0]);
            	printf("%d %d %d\n", *p[1], *p[2], *p[0]);
            	return 0;
            }
            /** 출력
            1 3 5
            1 3 5
            1 3 5
            1 3 5
            **/
            ```
            
    4. 2차원 배열과 2차원 포인터
        1. 2차원 배열에서 배열명만 단독으로 사용할 경우 2차원 포인터와 동일
        2. 2차원 배열일 때 : `배열명[i][j]` / `*배열명[i]` / `**(배열명+i)` 로 값 도출
        3. 2차원 포인터는 `int **p, **q;` 형식으로 선언 가능하나, 2차원 포인터는 2차원 배열에서 한 덩어리의 크기를 알 수 없기 때문에 열의 개수를 명시하는 형태로 포인터 변수를 선언한다.
        4. 포인터 변수 선언시 괄호가 없으면 2차원 배열에 대한 포인터가 아닌 포인터 배열이 된다
        `자료형(*포인터 변수)[열의 크기];`
        - 예시
            1. 메모리 구조 
            `int a[3][2] = {{1,2}, {3,4}, {5,6}};`
            `int (*p)[2] = a;`
            `int (*q)[2] = a+1;`
                
                
                |  | 주기억장치 |  |
                | --- | --- | --- |
                | &a[0][0] == a[0] , p | 1 | a[0][0] |
                | &a[0][1] | 2 | a[0][1] |
                | &a[1][0] | 3 | a[1][0] |
                | &a[1][1] | 4 | a[1][1] |
                | &a[2][0] | 5 | a[2][0] |
                | &a[2][1] | 6 | a[2][1] |
                |  |  |  |
                | p | a == a[0] ==a[0][0] |  |
                
                |  | 주기억장치 |  |
                | --- | --- | --- |
                | a[0] | 1 | a[0][0] |
                |  | 2 | a[0][1] |
                | a[1] , q | 3 | a[1][0] |
                |  | 4 | a[1][1] |
                |  | 5 | a[2][0] |
                | a[2] | 6 | a[2][1] |
                |  |  |  |
                | q | a+1 == a[1] ==a[1][0] |  |
            
            ```c
            #include <stdio.h>
            int main(){
            	int a[3][2] = {{1,2}, {3,4}, {5,6}};
            	int (*p)[2] = a;
            	int (*q)[2] = a+1;
            	printf("%d %d %d\n", a[0][0], a[0][1], a[1][0]);
            	printf("%d %d %d\n", p[0][0], p[0][1], p[1][0]);
            	printf("%d %d %d\n", q[0][0], q[0][1], q[1][0]);
            	return 0;
            }
            /** 출력
            1 2 3
            1 2 3
            3 4 5
            **/
            ```
            
            1. `int (*p)[2] = a;`
                1. p라는 2차원 배열 변수에 a를 저장
                2. p는 2차원 배열이므로 a[0][0]번지의 2차 주소 저장
                    1. a == &a[0] ⇒ `(배열+i) == &배열[i]`
                    2. &a[0] == &(&a[0])[0]
                3. 타입을 나타내는 `int *` 와 열의 개수를 나타내는 `[2]` 를 제외하면 p = a이므로 p와 a는 동일 값
            2. `int (*q)[2] = a+1;`
                1. q라는 2차원 배열 변수에 a+1을 저장
                2. q는 2차원 배열이므로 a[1][0] 번지의 2차 주소를 저장
                    1. a == &a[1] ⇒ `(배열+i) == &배열[i]`
                    2. &a[1] == &(&a[1])[0]
                3. 타입을 나타내는 `int *` 와 열의 개수를 나타내는 `[2]` 를 제외하면 q = a+1 이므로 q == a+1 ==&a[1]
            3. `printf("%d %d %d\n", a[0][0], a[0][1], a[1][0]);`
                1. a[0][0] == 1;
                2. a[0][1] == 2;
                3. a[1][0] == 3;
            4. `printf(”%d %d %d\n", p[0][0], p[0][1], p[1][0]);`
                1. p[0][0] == a[0][0] == 1;
                2. p[0][1] == a[0][1] == 2;
                3. p[1][0] == a[1][0] == 3;
            5. `printf("%d %d %d\n", q[0][0], q[0][1], q[1][0]);`
                1. q[0][0] == a[1][0] == 3;
                    1. q[0][0] == **(q[0]) ⇒ `**(배열+i) == 배열[i]`
                    2. *(q[0]) == *(&a[1][0]) == a[1][0]
                2. q[0][1] == a[1][1] == 4;
                    1. q[0][1] == *(q[0]+1);
                    2. *(q[0]+1) == *(&a[1][0]+1) 
                    3. *(&a[1][0]+1) == *(a[1]+1) ⇒  `&a[1][0] == a[1]` ⇒ `배열+i == &배열[i]`
                    4. *(a[1]+1) == a[1][1] ⇒ `배열+i == &배열[i]`
                3. q[1][0] == a[2][0] == 5;
                    1. q[1][0] == *(q[1]+0) == *(q[1])
                    2. q[1] == a[2] ⇒ q + 1 == a + 2 == &q[1] == &a[2] ⇒ q = a+1
                    3. q[1][0] == a[2][0]
4. 구조체와 포인터
    1. 구조체 변수와 구조체 포인터
        1. `.` : 일반 구조체 변수로 접근할 때 사용
        2. `->` : 구조체 포인터로 접근할 때 사용
        - 예시
            1. 메모리구조
            `struct Student s = {'F', 21};`
            `struct Student *p = &s;`
            
            |  | 주기억장치 |  |
            | --- | --- | --- |
            | s | F | s.gender |
            |  | 21 | s.age |
            |  |  |  |
            | p | s 주소 |  |
            
            ```c
            #include <stdio.h>
            struct Student{
            	char gender;
            	int age;
            };
            int main(){
            	struct Student s = {'F', 21};
            	struct Student *p = &s;
            	printf("%c %d\n", s.gender, s.age);
            	printf("%c %d\n", (&s) -> gender, (&s) -> age);
            	printf("%c %d\n", p -> gender, p -> age);
            	printf("%c %d\n", (*p).gender, (*p).age);
            	printf("%c %d\n", p[0].gender, p[0].age);
            	return 0;
            }
            /** 출력
            F 21
            F 21
            F 21
            F 21
            F 21
            **/
            ```
            
            1. Student라는 구조체 틀 생성
            2. Student 구조체에 gender라는 char(문자)형 변수 선언
            3. Student 구조체에 age라는 int(정수)형 변수 선언
            4. struct Student 타입의 s라는 이름의 변수선언
            5. p라는 포인터에 s의 주소 저장
            6. `printf("%c %d\n", s.gender, s.age);`
                1. s에 포함된 변수 값 출력
            7. `printf("%c %d\n", (&s) -> gender, (&s) -> age);`
                1. s의 주소에 포함된 변수 값 출력
            8. `printf("%c %d\n", p -> gender, p -> age);`
                1. p가 가리키는 구조체 값들을 출력
            9. `printf("%c %d\n", (*p).gender, (*p).age);`
                1. p가 가리키는 값(s 구조체) 출력
            10. `printf("%c %d\n", p[0].gender, p[0].age);`
                1. p는 1차원 포인터이므로 p[0]으로 s구조체에 접근가능
    2. 1차원 구조체 배열과 1차원 구조체 포인터
        1. 1차원 구조체 배열에서 배열명만 단독으로 사용할 경우 1차원 구조체 포인터와 동일
        2. 1차원 배열일 때 값 가져오는 법 : 
            1. `배열명[i].변수명`
            2. `(*(배열명 + i)).변수명`
            3. `배열명 → 변수명`
            4. `(배열명 + i) → 변수명`
        3. 1차원 포인터일 때 값 가져오는 법 : 
            1. `p[i].변수명`
            2. `(*(p + i)).변수명`
            3. `p → 변수명`
            4. `(p + i) → 변수명`
        - 예시
            1. 메모리구조
            `struct Student s[3] = {’F’, 21, ‘M’, 20, ‘M’, 24};`
            `struct Student *p = s;`
                
                
                |  | 주기억장치 |  |
                | --- | --- | --- |
                | s[0] | F | s[0].gender |
                |  | 21 | s[0].age |
                | s[1] | M | s[1].gender |
                |  | 20 | s[1].age |
                | s[2] | M | s[2].gender |
                |  | 24 | s[2].age |
                |  |  |  |
                | p | s 주소 |  |
            
            ```c
            #include <stdio.h>
            struct Student {
            	char gender;
            	int age;
            };
            int main(){
            	struct Student s[3] = {'F', 21, 'M', 20, 'M', 24};
            	struct Student *p = s;
            	printf("%c, %d\n", s[0].gender, s[0].age);
            	printf("%c, %d\n", (*s).gender, (*s).age;
            	printf("%c, %d\n", s -> gender, s -> age);
            	printf("%c, %d\n", (s+1) -> gender, (s+1) -> gender);
            	printf("%c, %d\n", p[0].gender, p[0].age);
            	printf("%c, %d\n", (*p).gender, (*p).age;
            	printf("%c, %d\n", p -> gender, p -> age);
            	printf("%c, %d\n", (p+1) -> gender, (p+1) -> age;
            	return 0;
            };
            /** 출력
            F 21
            F 21
            F 21
            M 20
            F 21
            F 21
            F 21
            M 20
            **/
            ```
            
            1. Student라는 구조체 틀을 생성
            2. Student 구조체에 문자형 변수 gender 선언
            3. Student 구조체에 정수형 변수 age 선언
            4. struct Student 타입을 3개 가진 배열 선ㅇ너
            5. 포인터 변수 p에 s의 주소 저장
            6. `printf("%c, %d\n", s[0].gender, s[0].age);`
                1. s의 0번째 인덱스의 값들 출력
            7. `printf("%c, %d\n", (*s).gender, (*s).age;`
                1. s가 가리키는 값(*s) == s[0]
            8. `printf("%c, %d\n", s -> gender, s -> age);`
                1. s는 배열이므로 s단독으로 쓰면 1차원포인터
                2. s는 구조체 변수를 →로 가리킴
            9. `printf("%c, %d\n", (s+1) -> gender, (s+1) -> gender);`
                1. s의 1번째 구조체의 값들 출력
            10. `printf("%c, %d\n", p[0].gender, p[0].age);`
                1. p가 가리키는 0번째 구조체 값 출력
            11. `printf("%c, %d\n", (*p).gender, (*p).age;`
                1. p가 가리키는 값(s[0]구초체)의 값 출력
            12. `printf("%c, %d\n", p -> gender, p -> age);`
                1. p는 1차원 포인터이므로 p는 구조체 변수를 →로 가리킴
            13. `printf("%c, %d\n", (p+1) -> gender, (p+1) -> age;`
5. 함수 포인터
    1. 함수의 주소를 저장하고, 해당 주소의 함수를 호출하는데 사용하는 포인터
    2. `리턴타입 (*함수_포인터)(함수 파라미터);`
    - 예시
        
        ```c
        #include <stdio.h>
        void fn1(){
        	printf("fn1 함수\n");
        }
        int fn2(int a){
        	[printf("fn2 함수: %d\n", a);
        	return 0;
        }
        int main(){
        	void (*pf1)();
        	int (*pf2)(int);
        	fn1();
        	fn2(5);
        	pf1 = fn1;
        	pf2 = fn2;
        	pf1();
        	pf2(2);
        	return 0;
        }
        /** 출력
        fn1 함수
        fn2 함수: 5
        fn1 함수
        fn2 함수: 2
        **/
        ```
        
        1. `void (*pf1)();` 
            1. `pf1`이라는 함수 포인터 선언
            2. `pf1`은 파라미터가 없는 함수를 가리킬 수 있음
        2. `int (*pf2)(int);`
            1. `pf2`라는 함수 포인터 선언
            2. `pf2`는 int형 1개를 파라미터로 갖는 함수를 가리킬 수 있음
        3. `fn1();`
            1. fn1 함수를 호출하여 fn1 내에 있는 printf 함수의 “fn1 함수” 출력
        4. `fn2(5);`
            1. fn2 함수를 호출하여 fn2 내에 있는 print 함수의 “fn2 함수: 5” 출력
        5. `pf1 = fn1;`
            1. pf1에 fn1 함수 대입
            2. pf1 == fn1이 됨
        6. `pf2 = fn2;`
            1. pf2에 fn2 함수 대입
            2. pf2 == fn2
        7. `pf1();`
            1. pf1은 fn1과 동일하므로 fn1을 호출하여 함수 실행
        8. `pf2(2);`
            1. pf2는 fn2와 동일하므로 fn2를 호출하여 함수 실행
6. 사용자 정의 함수 포인터
    1. 사용자 정의 함수의 반환 값으로 포인터를 전달받을 수 있다.
    - 예시
        
        ```c
        #include <stdio.h>
        #include <string.h>
        char n[6];
        char *soojebi(){
        	strcpy(n, "hello");
        	return n;
        }
        int main(){
        	char *p = soojebi();
        	printf("%s\n", p);
        	return 0;
        }
        //  출력: hello
        ```
        
        1. `int main(){`
            1. main 함수부터 시작
        2. `char *p = soojebi();`
            1. soojebi 함수 호출
        3. `char *soojebi(){`
            1. soojebi 함수 실행
        4. `strcpy(n, "hello");`
            1. n이라는 문자형 배열에 hello 저장
            
            | n[0] | n[1] | n[2] | n[3] | n[4] | n[5] |
            | --- | --- | --- | --- | --- | --- |
            | h | e | l | l | o | NULL |
        5. `return n;`
            1. n은 &n[0]으로 문자형 포인터를 soojebi 함수를 호출한 부분에 반환
        6. `char *p = soojebi();`
            1. soojebi()가 &n[0]이므로 p = &n[0];과 같음
            2. n의 0 인덱스 주소를 저장
        7. `printf("%s\n", p);`
            1. p는 n의 0번째 인덱스 주소이고, printf 함수에서 %s는 NULL 전까지 문자열 출력이므로 hello를 출력
